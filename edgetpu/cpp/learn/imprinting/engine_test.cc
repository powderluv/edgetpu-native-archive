#include "edgetpu/cpp/learn/imprinting/engine.h"

#include "edgetpu/cpp/learn/imprinting/imprinting_test_base.h"
#include "gflags/gflags.h"
#include "glog/logging.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

namespace coral {
namespace learn {
namespace imprinting {
namespace {

class ImprintingEngineTest : public ImprintingTestBase {
 protected:
  struct TrainingDatapoint {
    TrainingDatapoint(const std::vector<Image>& images_,
                      const int groundtruth_class_id_)
        : images(images_), groundtruth_class_id(groundtruth_class_id_) {}
    const std::vector<Image> images;
    const int groundtruth_class_id;
  };

  void CreateImprintingEngine(const std::string& model_path,
                              bool keep_classes) {
    imprinting_engine_ =
        absl::make_unique<ImprintingEngine>(model_path, keep_classes);
  }

  void OnlineTrain(const std::vector<TrainingDatapoint>& training_datapoints) {
    for (const auto& training_datapoint : training_datapoints) {
      imprinting_engine_->Train(training_datapoint.images,
                                training_datapoint.groundtruth_class_id);
    }
  }

  void OnlineTest(const std::vector<TestDatapoint>& test_datapoints) {
    for (const auto& test_datapoint : test_datapoints) {
      const auto& results =
          imprinting_engine_->RunInference(test_datapoint.image);
      int class_max = std::distance(
          results.begin(), std::max_element(results.begin(), results.end()));
      EXPECT_EQ(test_datapoint.predicted_class_id, class_max);
      EXPECT_GT(results[class_max], test_datapoint.classification_score);
    }
  }

  void OnlineTrainAndSave(
      const std::vector<TrainingDatapoint>& training_datapoints,
      const std::string& output_file_path) {
    OnlineTrain(training_datapoints);
    // Remove output model generated by previous tests.
    std::remove(output_file_path.c_str());

    imprinting_engine_->SaveModel(output_file_path);
  }

  std::unique_ptr<ImprintingEngine> imprinting_engine_;
};

TEST_P(ImprintingEngineTest,
       TrainWithMobileNetV1L2NormAndRealImagesNotKeepClasses) {
  CreateImprintingEngine(
      GenerateInputModelPath("mobilenet_v1_1.0_224_l2norm_quant"),
      /*keep_classes=*/false);
  const std::vector<TrainingDatapoint> training_datapoints = {
      TrainingDatapoint({cat_train_0_}, 0),
      TrainingDatapoint({hotdog_train_0_, hotdog_train_1_}, 1),
      TrainingDatapoint({dog_train_0_}, 2)};
  const std::vector<TestDatapoint> test_datapoints = {
      TestDatapoint(cat_train_0_, 0, 0.99f),
      TestDatapoint(hotdog_train_0_, 1, 0.99f),
      TestDatapoint(dog_train_0_, 2, 0.99f),
      TestDatapoint(cat_test_0_, 0, 0.99f),
      TestDatapoint(hotdog_test_0_, 1, 0.99f),
      TestDatapoint(dog_test_0_, 2, 0.99f)};
  const std::string output_file_path =
      GenerateOutputModelPath("retrained_model_notkeep");
  OnlineTrainAndSave(training_datapoints, output_file_path);
  TestTrainedModel(test_datapoints, output_file_path);
}

TEST_P(ImprintingEngineTest,
       RunInferenceWithMobileNetV1L2NormAndRealImagesNotKeepClasses) {
  CreateImprintingEngine(
      GenerateInputModelPath("mobilenet_v1_1.0_224_l2norm_quant"),
      /*keep_classes=*/false);
  const std::vector<TrainingDatapoint> training_datapoints = {
      TrainingDatapoint({cat_train_0_}, 0),
      TrainingDatapoint({hotdog_train_0_, hotdog_train_1_}, 1),
      TrainingDatapoint({dog_train_0_}, 2)};
  const std::vector<TestDatapoint> test_datapoints = {
      TestDatapoint(cat_train_0_, 0, 0.99f),
      TestDatapoint(hotdog_train_0_, 1, 0.99f),
      TestDatapoint(dog_train_0_, 2, 0.99f),
      TestDatapoint(cat_test_0_, 0, 0.99f),
      TestDatapoint(hotdog_test_0_, 1, 0.99f),
      TestDatapoint(dog_test_0_, 2, 0.99f)};
  OnlineTrain(training_datapoints);
  OnlineTest(test_datapoints);
}

// This test should perform almost the same with
// TrainWithMobileNetV1L2NormAndRealImagesNotKeepClasses.
TEST_P(ImprintingEngineTest,
       TrainWithMobileNetV1L2NormAndRealImagesOnlineTraining) {
  CreateImprintingEngine(
      GenerateInputModelPath("mobilenet_v1_1.0_224_l2norm_quant"),
      /*keep_classes=*/false);
  const std::vector<TrainingDatapoint> training_datapoints = {
      TrainingDatapoint({cat_train_0_}, 0),
      TrainingDatapoint({hotdog_train_0_}, 1)};
  const std::string output_file_path =
      GenerateOutputModelPath("retrained_model_notkeep");
  OnlineTrainAndSave(training_datapoints, output_file_path);

  CreateImprintingEngine(output_file_path, /*keep_classes=*/true);
  const std::vector<TrainingDatapoint> training_datapoints_new = {
      TrainingDatapoint({hotdog_train_1_}, 1),
      TrainingDatapoint({dog_train_0_}, 2)};
  const std::vector<TestDatapoint> test_datapoints = {
      TestDatapoint(cat_train_0_, 0, 0.99f),
      TestDatapoint(hotdog_train_0_, 1, 0.99f),
      TestDatapoint(dog_train_0_, 2, 0.99f),
      TestDatapoint(cat_test_0_, 0, 0.99f),
      TestDatapoint(hotdog_test_0_, 1, 0.99f),
      TestDatapoint(dog_test_0_, 2, 0.99f)};
  const std::string output_file_path_new =
      GenerateOutputModelPath("online_retrained_model");
  OnlineTrainAndSave(training_datapoints_new, output_file_path_new);
  TestTrainedModel(test_datapoints, output_file_path_new);
}

TEST_P(ImprintingEngineTest,
       TrainWithMobileNetV1L2NormAndRealImagesKeepClasses) {
  CreateImprintingEngine(
      GenerateInputModelPath("mobilenet_v1_1.0_224_l2norm_quant"),
      /*keep_classes=*/true);
  const std::vector<TrainingDatapoint> training_datapoints = {
      TrainingDatapoint({cat_train_0_}, 1001),
      TrainingDatapoint({hotdog_train_0_, hotdog_train_1_}, 1002),
      TrainingDatapoint({dog_train_0_}, 1003)};
  const std::vector<TestDatapoint> test_datapoints = {
      TestDatapoint(cat_train_0_, 1001, 0.99f),
      TestDatapoint(hotdog_train_0_, 1002, 0.99f),
      TestDatapoint(dog_train_0_, 1003, 0.99f),
      TestDatapoint(cat_test_0_, 1001, 0.99f),
      TestDatapoint(hotdog_test_0_, 1002, 0.96f),
      TestDatapoint(dog_test_0_, 1003, 0.74f)};
  const std::string output_file_path =
      GenerateOutputModelPath("retrained_model_keep");
  OnlineTrainAndSave(training_datapoints, output_file_path);
  TestTrainedModel(test_datapoints, output_file_path);
}

TEST_P(ImprintingEngineTest,
       RunInferenceWithMobileNetV1L2NormAndRealImagesKeepClasses) {
  CreateImprintingEngine(
      GenerateInputModelPath("mobilenet_v1_1.0_224_l2norm_quant"),
      /*keep_classes=*/true);
  const std::vector<TrainingDatapoint> training_datapoints = {
      TrainingDatapoint({cat_train_0_}, 1001),
      TrainingDatapoint({hotdog_train_0_, hotdog_train_1_}, 1002),
      TrainingDatapoint({dog_train_0_}, 1003)};
  const std::vector<TestDatapoint> test_datapoints = {
      TestDatapoint(cat_train_0_, 1001, 0.99f),
      TestDatapoint(hotdog_train_0_, 1002, 0.99f),
      TestDatapoint(dog_train_0_, 1003, 0.99f),
      TestDatapoint(cat_test_0_, 1001, 0.99f),
      TestDatapoint(hotdog_test_0_, 1002, 0.96f),
      TestDatapoint(dog_test_0_, 1003, 0.74f)};
  const std::string output_file_path =
      GenerateOutputModelPath("retrained_model_keep");
  OnlineTrain(training_datapoints);
  OnlineTest(test_datapoints);
}

TEST_P(ImprintingEngineTest,
       TrainImprintedRetrainedMobileNetV1L2NormWithRealImagesNotKeepClasses) {
  CreateImprintingEngine(GenerateInputModelPath("retrained_model_notkeep"),
                         /*keep_classes=*/false);
  const std::vector<TrainingDatapoint> training_datapoints = {
      TrainingDatapoint({hotdog_train_0_}, 0),
      TrainingDatapoint({dog_train_0_}, 1)};
  const std::vector<TestDatapoint> test_datapoints = {
      TestDatapoint(hotdog_train_0_, 0, 0.99f),
      TestDatapoint(dog_train_0_, 1, 0.99f),
      TestDatapoint(hotdog_test_0_, 0, 0.99f),
      TestDatapoint(dog_test_0_, 1, 0.99f)};
  const std::string output_file_path =
      GenerateOutputModelPath("retrained_imprinting_retrained_model_notkeep");
  OnlineTrainAndSave(training_datapoints, output_file_path);
  TestTrainedModel(test_datapoints, output_file_path);
}

INSTANTIATE_TEST_CASE_P(ImprintingEngineTest, ImprintingEngineTest,
                        ::testing::Values(false, true));
}  // namespace
}  // namespace imprinting
}  // namespace learn
}  // namespace coral

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  gflags::ParseCommandLineFlags(&argc, &argv, true);
  return RUN_ALL_TESTS();
}
